## Polimorfismo
Il polimorfismo è uno dei punti cardine della programmazione orientata agli oggetti oltre all’ereditarietà
Una variabile di un certo tipo a può contenere un riferimento a un oggetto del tipo A o di qualsisasi sua sottoclasse

```java
// a è il riferimento di animale ma ho usato il costruttore di Gatto
Animale a = new Gatto();
a = new Chihuahua();
```

Posso chiamare un’istanza di tipo Animale con il costruttore di qualsiasi sottoclasse.
La selezione del metodo da chiamare avviene in base all’effettivo tipo dell’oggetto riferito alla variabile 
```java
Animale a = new Gatto();
a.emettiVerso(); // "miaoo"
a = new Chihuahua();
a.emettiVerso(); // "bau bau"
```

	Utilizzando il polimorfismo posso chiamare solamente metodi definito del tipo dentro animale

Binding: associale ad ogni variabile il proprio tipo
Nei linguaggi compilati (Java, C…), il compilatore inizialemnte osserva il codice in modo statico senza eseguirlo per creare una tabella dei binding per associare variabili e tipi (**binding statico**), mentre nei linguaggi interpretati (Python) il binding viene eseguito in modo dinamico a runtime. Il binding dinamico esiste anche in java e viene eseguito dalla JVM quando, attraverso il polimorfismo, utilizzo il costruttore di una sottoclasse del tipo di definizione
Quando chiamo un metodo implementato utilizzando polimorfismo viene sempre eseguito il codice del costruttore chiamato

## Binding statico
Il binding statico consiste nell’associale una variabile al suo tipo, e viene svolto in java dal compilatore.

Il polimorfisrmo, come implementato in java, vede la JVM elaborare il binding dinamico, poiché l’associazione tra una variabile di riferimento e un metodo da chiamare viene stabilita a tempo di esecuzione

Il binding dinamico entra in gioco quando chiamiamo dei metodi

Il polimorfismo dunque ci permette di utilizzare un metodo senza dover conosce il tipo esatto (la classe) su cui si invoca il metodo

@Override serve a noi programmatori per chiedere al compilatore se esiste una classe superiore con uno stesso metodo. Se ciò non accade mi viene restituito un errore, e vuol dire quindi che non sto facendo alcun tipo di overriding
**<3**
Posso anche chiamare un metodo di un supercostruttore attraverso `super.metodo()` all’interno di un overriding in una sottoclasse. In questo caso il binding viene fatto in modo dinamico (non lo riesco a capire leggendo direttamente il codice ma devo chiamare il costruttore suoeriore)
