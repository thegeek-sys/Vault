Come funziona il compilatore e la java virtual machine? Come viene gestita la memoria?

![[Screenshot 2024-03-12 alle 09.16.37.png]]

Quando viene caricata una classe la prima cosa che la JVM è controllare se ci sono campi statici che vengono quindi allocati nel metaspace (questi essendo campi di classe vengono inizializzati implicitamente).
A questo punto viene creato un frame di attivazione nello stack il metodo main che viene chiamato all’avvio di un programma. All’interno di questo frame metterò le variabili locali che vengono allocate. Se ad esempio passo ad un oggetto una variabile questa sarà allocata all’interno dell’heap collegato tramite una freccia all’oggetto stesso

![[document-92-109.pdf]]

```java
public class Tornello {
	static private int passaggi;
	
	public void passa() {passaggi++;}
	public static void int getPassaggi() {return passaggi;}
	
	public static void main(String[] args) {
		Tornello t1 = new Tornello();
		t1.passa();
		Tornello t2 = new Tornello();
		for (int k=0; k<10; k++) t2.passa();
		int g;
		String s=null;
		// fotografa lo stato della memoria
	}
}
```

![[Screenshot 2024-03-12 alle 09.43.54.png]]

null è una parola chiave intende dire che una variabile o un campo viene utilizzato per gli oggetti (String o vettori) intende dire che non ci sta alcun riferimento ad un oggetto nell’heap (per questo su s non viene fatta alcuna freccia). undefined lo si ha quando non assegno nulla e non lo posso stampare mentre null è un valore leggittimo assegnabile ad una variabile e dunque il compilatore non mi restituisce alcun tipo di errore quando la provo a chiamare

