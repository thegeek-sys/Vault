Per rappresentare un’informazione devo codificare dentro 32 l’intera informazione
- 6 bit vengono riservati per il tipo di operazioni
- 3x5 bit per indicizzare uno dei 32 registri 
- 5 bit di shift amount per eseguire operazioni di shifting 
- 6 bit per specificare il tipo di operazione eseguita

Tutte le operazioni R-type non utilizzzano la ram

![[Screenshot 2024-03-08 alle 11.24.02.png]]

Quindi se faccio `add $t0,$s1,$s2`
![[Screenshot 2024-03-08 alle 11.27.03.png]]

`rd` corrisponderà a t0
`rs` corrisponderà a s1
`rt` corrisponderà a s2

Ci potrebbe capitare però che a volte necessitiamo solamente di 16 bit per l’istruzioni e quindi lasciare altri 16 bit per indicare l’indirizzo di memoria (o meglio una sua parte!) o una costante come avviene ad esempio nella somma immediata.
Quindi se faccio `addi $t2,$s2,4`

![[Screenshot 2024-03-08 alle 11.33.08.png]]

Che in esadecimale corrisponde a `0x2150004`

> [!warning]
> Da questa forma nasce della confusione poiché in questo caso `rs` e `rd` sono invertiti

![[Screenshot 2024-03-08 alle 11.36.00.png]]


Le istruzioni della CPU tutte da 32 bit con formato molto simile
R-type
- senza accesso a memoria
- istruzioni aritmetico/lgoche
I-type:
- load/store
- salti condizionati (salto relativo al PC)
J-type
- salti non condizionati → poiché non ho la necessità di altri registri posso utilizzare tutti e 26 i bit restanti per l’indirizzo di memoria (32 meno op code)


Mars è un simulatore di processore mips ma che contiene anche un ide per visualizzare lo stato della memoria

ASSEMBLY
il tasto della chiave inglese e cacciavite assembla il codice

## Principi di progettazione
1. La semplicità favorisce la regolarità
2. La semplicità favorisce la regolarità
3. Un buon progetto richiede buoni compromessi

## Memoria
![[Screenshot 2024-03-08 alle 12.22.02.png]]


Organizzazione memoria (RAM)
- I primi 4 byte sono riservati al kernel
- Poi abbiamo il programma dell’utente (anche chiamato `.text`) (il mio codice)
- In seguito i dati statici (`.data`) allocati in assegnamento
- Infine ho lo spazio libero in cui metto i dati dinamici e lo stack
GP → indica fino a dove interpretare lo spazio libero come dati dinamici (per le chiamate nidificate)
SP → indica fino a dove interpretare lo spazio libero come stack (per gestire i dati dinamici non-locali)


Il Program Counter viene utilizzato dalla CPU per tenere traccia di dove ci troviamo. Ogni volta che viene una istruzione viene letta il PC viene incrementato di 4 byte


Cosa sa fare la CPU?
Le fasi di esecuzione di una istruzione sono:
- Fetch/caricamento della istruzione → Dalla posizione indicata dal Program Counter (dalla RAM alla CPU) (particolarmente lento)
- Decodifica/riconoscimento dell’istruzione → la control unit legge i 6 bit dell’op code e inizia a settare la cpu
- Load/caricamento di eventuali argomenti → leggo i registri (molto veloce)
- Esecuzione della istruzione → eseguita in genere dall’alu
- Store/salvataggio del risultato → srivere il risultato sulla cpu o ram
- Aggiornamento del Program Counter → vado avanti nel programma o faccio un salto

Tipologie di istruzione
- LOAD/STORE
- Logico/Aritmetiche
- Salti condizionati e indcondizionati (usati per cicli e per uscire da una sottoroutiine) (quando si entra in una funzione sto facendo un jump nella ram e quando esco faccio un altro jump indietro)
- Gestione delle eccezioni/interrupt
- Istruzioni di trasferimento dati

Come indicare alla CPU cosa fare
La codifica dell’istruzione deve indicare
- quale operazione va svolta (opcode)
- Quali argomenti sono necessari
- Dove scrivere il risultato

Indirizzamento (come codificare gli argomenti dell’istrzione)
- implicito

