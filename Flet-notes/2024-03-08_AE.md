Per rappresentare un’informazione devo codificare dentro 32 l’intera informazione
- 6 bit vengono riservati per il tipo di operazioni
- 3x5 bit per indicizzare uno dei 32 registri 
- 5 bit di shift amount per eseguire operazioni di shifting 
- 6 bit per specificare il tipo di operazione eseguita

Tutte le operazioni R-type non utilizzzano la ram

![[Screenshot 2024-03-08 alle 11.24.02.png]]

Quindi se faccio `add $t0,$s1,$s2`
![[Screenshot 2024-03-08 alle 11.27.03.png]]

`rd` corrisponderà a t0
`rs` corrisponderà a s1
`rt` corrisponderà a s2

Ci potrebbe capitare però che a volte necessitiamo solamente di 16 bit per l’istruzioni e quindi lasciare altri 16 bit per indicare l’indirizzo di memoria (o meglio una sua parte!) o una costante come avviene ad esempio nella somma immediata.
Quindi se faccio `addi $t2,$s2,4`

![[Screenshot 2024-03-08 alle 11.33.08.png]]

Che in esadecimale corrisponde a `0x2150004`

> [!warning]
> Da questa forma nasce della confusione poiché in questo caso `rs` e `rd` sono invertiti

![[Screenshot 2024-03-08 alle 11.36.00.png]]


Le istruzioni della CPU tutte da 32 bit con formato molto simile
R-type
- senza accesso a memoria
- istruzioni aritmetico/lgoche
I-type:
- load/store
- salti condizionati (salto relativo al PC)
J-type
- salti non condizionati → poiché non ho la necessità di altri registri posso utilizzare tutti e 26 i bit restanti per l’indirizzo di memoria (32 meno op code)


Mars è un simulatore di processore mips ma che contiene anche un ide per visualizzare lo stato della memoria

ASSEMBLY
il tasto della chiave inglese e cacciavite assembla il codice