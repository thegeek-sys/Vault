trasformazioni: per mantenere correttezza semantica del loop ma poterlo parallelizzare

## Loop skewing
Another technique involves the rearrangement of the loop body statements.

```c
for (int i=1; i<N; i++) {
	y[i] = f(x[i-1]); // S1
	x[i] = x[i] + c[i]; // S2
}
```

Solution: make sure the statements that consume the calculated values cause the dependence, use values generated during the same iteration
(non usare i-1)

```c
y[1] = f(x[0]);
for (int i=1; i<N; i++) {
	x[i] = x[i] + c[i];
	y[i+1] = f(x[i]);
}
x[N-1] = x[N-1] + c[N-1];
```

>[!question] How to do loop skewing?
>>[!tip] Unroll the loop and see the repetition pattern
>
>```c
>y[1] = f(x[0]);
>x[1] = x[1]+c[1];
>y[2] = f(x[1]);
>x[2] = x[2]+c[2];
>...
>y[N-2] = f(x[N-3]);
>x[N-2] = x[N-2]+ c[N-2];
>y[N-1] = f(x[N-2]);
>x[N-1] = x[N-1]+ c[N-1];
>```
>
>li devo raggruppare in 
>```c
>x[1] = x[1]+c[1];
>y[2] = f(x[1]);
>```
>
>quindi prima e ultima iterazione le metto fuori dal ciclo tutte le altre le raggruppo in questo modo dentro

## Partical parallelization
### Iteration space dependency graph
ISDG is made of up of nodes that represent a single execution of the loop body, and edges that represent dependencies

```c
for (int i=1; i<N; i++)
	for (int j=1; j<M; j++)
		data[i][j] = data[i-1][j] + data[i-1][j-1];
```

ragionare sulle dipendenzew in un loop annidato risulta tosto

No edge/dipendencies between nodes on the same row (i.e. we can parallelize the j-loop)

![[Pasted image 20251203143929.png]]

freccie rappresnetano dipendenze tra iterazioni diverse

```c
for (int i=1; i<N; i++)
#pragma omp parallel for
	for (int j=1; j<M; j++)
		data[i][j] = data[i-1][j] + data[i-1][j-1];
```

visto che le dipendenze sono solamente tra livelli diversi, posso parallelizzare il for che ha 