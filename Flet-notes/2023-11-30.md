## Fibonacci ricorsivo
se tolgo il caso base ad una ricorsione mi viene restituito da python un errore di tipo `RecursionError`

In una ricorsione una funzione chiama sè stessa e ci sta un caso base

call e return affinché la ricorsione funzioni devono essere tutti simmetrici

## Complessità di Fibonacci naive
$$
T(n) = T(n-1) + T(n-2) + \Theta(n)
$$

## Recursion + memorization
Caching. Nel caso in cui devo lavorare su numeri molto grandi con ricorsione mi conviene memorizzare i valori già calcolati piuttosto che ricalcolarli (per esempio in Fibonacci non mi serve ricalcolare più volte f(2) ). Il che mi permette di tagliare la complessità di un programma ricorsivo. Questo mi è possibile farlo attraverso un dizionario a cui appendo il valore di n ogni volta che viene calcolato in modo tale che ogni volta che esso mi serve mi basta fare una query al dizionario. Permettendomi quindi di tagliare la complessità e trasformandola da esponenziale a lineare diventa $ \Theta(n-1) $
Memorization vuol dire ignorare le chiamate ricorsive e semplicemente accedere alla memoria in tempo sotante (…)
