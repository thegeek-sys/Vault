## ArrayList e LinkedList
Basate su List, una sottointerfaccia di Collection e di Iterable
Le classi liste sono: ArrayList e LinkedList (estendono AbstractList e implementano l’interfaccia List)
ArrayList implementa la lista mediante un array (eventualmente ridimensionato) la cui capacità iniziale è 10 elementi.

LinkedList implementa la lista mediante elementi linkati


| Tipo      | Metodo                                                                                                                                                                                             |
| :-------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `boolean` | `add(E e)`<br>Appends the specific element to the end of the list                                                                                                                                  |
| `void`    | `add(int index, E element)`<br>Inserts the specific element at the specific position in the list                                                                                                   |
| `boolean` | `addAll(Collection<? extends E> c)`<br>Appends all of the elements in the specified collection to the end of this list, in the order that they are returned by the specified collection’s Iterator |
| `boolan`  | `addAll (int index, Collection<? extends E> c)`<br>Inserts all of the elements in the specified collection into this list, starting at the specified position                                      |
| `void`    | `clear()`<br>Removes all of the elements from this list                                                                                                                                            |
| `Object`  | `clone()`<br>Returns a shallow copy of this ArrayList instance                                                                                                                                     |


Alcuni metodi aggiuntivi di LinkedList

| Metodo                             | Descrizione                                                                                   |
| :--------------------------------- | :-------------------------------------------------------------------------------------------- |
| `void addFirst(E e)`               | Aggiungere l’elemento in testa alla lista                                                     |
| `void addLast(E e)`                | Aggiungere l’elemento in coda alla lista                                                      |
| `Iterator<E> descendingIterator()` | Restituire un iteratore che parte dall’ultimo elemento della lista e si sposta verso sinistra |


## Insiemi
Basati su Set, una sottointerfaccia di Collection e di Iterable
Gli elementi sono Collection che contengono elementi tutti distinti

### HashSet
```java
HashSet<String> nomi = new HashSet<String>();
HashSet<String> cognomi = new HashSet<String>();

nomi.add("mario");
cognomi.add("rossi");

nomi.add("mario");
cognomi.add("verdi");

nomi.add("luigi");
cognomi.add("rossi");

nomi.add("luigi");
cognomi.add("bianchi");

System.out.println(nomi);  // [mario, luigi]
System.out.println(cognomi);  // [verdi, bianchi, rossi]
```

### TreeSet
Gli elementi vengono mantenuti ordinati sulla base dell’ordinamento naturale definito sul tipo degli elementi
```java
TreeSet<String> nomi = new TreeSet<String>();
TreeSet<String> cognomi = new TreeSet<String>();

nomi.add("mario");
cognomi.add("rossi");

nomi.add("mario");
cognomi.add("verdi");

nomi.add("luigi");
cognomi.add("rossi");

nomi.add("luigi");
cognomi.add("bianchi");

System.out.println(nomi);  // [luigi, mario]
System.out.println(cognomi);  // [bianchi, rossi, verdi]
```

## Come funziona un HashSet
Si fonda sul concetto di **tabella hash**

se a.equals(b) →
$$
\text{se a.eqauls(b)} \Rightarrow \text{a.hashcode}== \text{b.hashcode}
$$

$$
\text{a.hashcode}== \text{b.hashcode} \nRightarrow \text{se a.eqauls(b)}
$$



Una hashmap fa uso delle liste linkate per tenere l’associazione chiave valore


## Mappe
una mappa mette in corrispondenza chiavi e valori e non può contenere chiavi duplicate
`java.util.Map` è un’interfaccia implementata da `HashMap`, `LinkedHashMap`, `TreeMap`

```java
public class MappaDelleFrequenze {
	private Map<String, Integer> frequenze = new HashMap<String, Integer>;
	public MappaDelleFrequenze(File file) throws IOException {
		Scanner in = new Scanner(file);
		while(in.hasNext()) {
			Singola parola = in.next();
			Integer freq = frequenze.get(parola);
			
			// parola mai incontrata (non presente nella mappa)
			if (freq == null)  frequenze.put(parola, 1);
			// incrementa il conteggio di frequenza della parola
			else               frequenze.put(parola, freq+1);
		}
	}
}
```


## TreeMap
Se vogliamo mantenere un ordinamento sulle chiavi (ovvero sulle parole) di cui calcoliamo la frequenza:
```java
public class MappaDelleFrequenze {
	private Map<String, Integer> frequenze = new TreeMap<String, Integer>();
	
	public MappaDelleFrequenze(File file) throws IOException {
		Scanner in = new Scanner(file);
		while(in.hasNext()) {
			Singola parola = in.next();
			Integer freq = frequenze.get(parola);
			
			// parola mai incontrata (non presente nella mappa)
			if (freq == null)  frequenze.put(parola, 1);
			// incrementa il conteggio di frequenza della parola
			else               frequenze.put(parola, freq+1);
		}
	}
}
```