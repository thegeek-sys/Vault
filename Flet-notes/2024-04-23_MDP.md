## Supplier
Funzione senza argomenti in input
```java
Supplier<String> stringSupplier = () -> "ciao";

Supplier<Person> personSupplier = Person::new;
personSupplier.get(); // new Person();
```

Le collection sono dotate di un metodo `forEach` che prende in input un’interfaccia `Consumer<? super T>` dove T è il tipo generico della collection

```java
Collection<String> c = Arrays.asList("aa", "bb", "cc");
c.forEach(s -> System.out.println(s));
c.forEach(System.out::println);
```

## Pila e coda
Due strutture dati fondamentali utili in un gran numero di attività
- Coda (FIFO → first-in, first-out)
- Pila o stack (LIFO → last-in, first-out)

### Coda
Esempi di coda:
- coda degli eventi relativi a mouse e tastiera
- coda di stampa
Esistono implementazioni standard della coda mediante l’interfaccia **`Queue`** (`LinkedList` implementa l’interfaccia `Queue`)
Operazioni principali:
- add → inserisce un elemento in coda
- remove → rimuove un elemento dall’inizio della coda
- peek → restituisce l’elemento all’inizio della coda senza rimuoverlo

### Pila
Esempi di pila:
- la pila di esecuzione (run-time stack) contenente i record di attivazione delle chiamate a metodi
- Nell’implementazione della ricorsione
Esiste un’implementazione standard mediante la classe **`Stack`** (implementa l’interfaccia `List`)
Operazioni principali:
- push → inserisce un elemento in cima alla pila
- pop → rimuove l’elemento in cima alla pila
- peek → restituisce l’elemento in cima alla pila senza rimuoverlo


## Alberi
Una struttura dati ricorsiva in cui ogni nodo possiede un padre tranne la radice. Gli alberi più comuni sono binari (ovvero con al più due figli per nodo)
![[Screenshot 2024-04-23 alle 09.45.18.png|center|250]]

Utilizziamo una classe annidata (interna se serve il riferimento all'albero) per rappresentare il nodo di un albero binario:
```java
public class BinaryTree {
	private Nodo root;
	
	public static class Nodo {
		private Nodo left;
		private Nodo right;
		private int valore;
		
		public Nodo(Nodo left, Nodo right, int valore) {
			this.left = left;
			this.right = right;
			this.valore = valore;
		}
	}
}
```


## Exceptions
Le eccezioni rappresentano un meccanismo utile a notificare e gestire gli errori. Un’eccezione indica che durante l’esecuzione si è verificato un errore
Il termine “eccezione” indica un comportamento anomalo, che si discosta dalla normale esecuzione; impararle a gestire rende il codice più robusto e sicuro


| Eccezione                   | Descrizione                                                                                                        |
| --------------------------- | ------------------------------------------------------------------------------------------------------------------ |
| `IndexOutOfBoundsException` | Accesso ad una posizione non valida di un array o una stringa (<0 o maggiore della sua dimensione)                 |
| `ClassCastException`        | Cast illecito di un oggetto ad una sottoclasse a cui non appartiene<br>Es. `Object x = new Integer(0); (Stringa)x` |

### Perché non restituire un “valore d’errore”?
Perché bisognerebbe restituire un valore “speciale” per ogni tipo d’errore e prevedere una codifica dei valori d’errore comune a tutti i metodi
Perché bisognerebbe gestire gli errori per ogni istruzione eseguita

```java
try {
	Svolgi compito 1
	Svolgi compito 2
	Svolgi compito 3
	Svolgi compito 4
}
catch(ExceptionType1 e1) {}
catch(ExceptionType2 e2) {}
catch(ExceptionType3 e3) {}
catch(ExceptionType4 e4) {}
finally {}
```

Gli errori vengono propagati verso l’alto lungo lo stack di chiamate. In un codice robusto non dobbiamo controllare esaustivamente tutti i possibili tipi di errore: il polimorfismo lo fa per noi, scegliendo l’intervento più opportuno

