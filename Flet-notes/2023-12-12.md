## Alberi di gioco → tris
Il gioco del tris può essere visto come un albero.
Nell’idea del codice è come se avessimo 2 giocatori che competono e vince chi riesce a mettere in fila 3 dei propri simboli. Invece ci sta la possibilità di pareggio quando manca una casella, e in qualsiasi modo riempiamo quella casella non ci sta possibilità di vittoria. Risulta quindi chiaro che i casi di parità e i casi di vittoria sono le foglie del nostro albero.
La board rappresenta uno stato (una condizione del gioco) e quando un giocatore fa una mossa arriviamo in un altro stato.

> `lezione22.py`
```python
state = [99, 1, 3, 5, 20]

def game(state, L=None):
	# mi salvo se sono nella prima chiamata
	start = False
	if L is None:
		# lo sono
		start = True
		# init una lista vouta
		L = []
	# definisco booleano per foglia
	leaf = True
	# provo le mosse
	for i in range(len(state)-1):
		pre, post = state[i, i+2]
		# se la mossa è verificata almeno una volta
		if pre % 2 == post % 2:
			# ricorsione, NON sono in una foglia
			leaf = False
			somma = pre + post
			# nuovo stato tutti tranne i e i+1 ma metto la somma
			state_next = state[:i]+[somma]+state[i+2:]
			# ricorsione su next state
			game(state_next, L)
		
	# se dato uno stato, non entriamo mai in ricorsione allora foglia
	if leaf:
		L.append((state, [ 'd' if s%2 == 1 else 'p' for s in state ]))
	# se era la prima chiamata torno L
	if start: return L
	

class GameTree:
	def __init__(self, state):
		
```