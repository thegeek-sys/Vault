NEssuna istruzione permette di caricare immediatamente 32 bit, bisogna spezzare questo caricamente in due istruzioni da 16 bit

Il problema delle funzioni in assembly è il fatto che posso passare al più 4 registri (4 valori da 32 bit o 2 da 64) e riceverne 2 (2 da 32 bit o 1 da 64).
Quindi mi potrebbe esser utile fare più chiamate a più funzioni. Ma quindi, come ricostruisco la memoria in ritorno?

Conviene preservare il precedente contenuto dei registri usati dalla funzione e ripristinarlo
- meno vincoli alla funzione chiamante
- nelle funzioni che chiamano altre funzioni, che perderebbero il contenuto almeno di $ra (se dentro una funzione, per il accesso ho dovuto fare ul jal, faccio una seconda chiamata ad un’altra funzione tramite jal mi perdo l’indirizzo del program counter del primo chiamante)

Le informazioni da preservare hanno un ciclo di vita caratteristico, dovuto al nidificarsi delle chiamate delle funzioni_
- salvo lo stato prima di chiamata 1
	- salvo stat prima di chiamata 2
		- …
	- ripristino stato prima di chiamata 2
- ripristino stato prima di chiamata 1

Questo è il comportamento di una pila (stack o LIFO), in cui aggiungere un elemento (push) e togliere l’ultimo inserito (pop). Viene realizzata con un vettore di cui si tiene l’indirizzo dell’ultimo elemento occupato nel registro $sp (Stack Pointer)

### esempio chiamata funzioni nidificate
- main chiama foo che chiama bar
- foo ha bisogno di 3 registri $s0, $s1, $s2
- bar ha bisogno di 2 registri $s0, $s1
- return address? (se ho jal nidificato lo perdo)
```arm-asm
main:
	...
	jal foo # $ra=PC+1

# sapendo che foo sporcherà tre registri vuol dire che
# dovrò salvare nello stack questi tre valori
# spostando il relativo stack pointer
foo:
	...
	jal bar # poiché questa istruzione cambierà $ra dovrò
			# salvarmi il precedente stato di $ra dentro
			# lo stack

bar:
	...
	jr $ra  # tornando indietro mi dovrò ricordare di 
			# svuotare lo stack e rimettere i valori 
			# precedentri (come $ra, $s0, $s1, $s2)
	
```