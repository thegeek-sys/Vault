Due send fatte a uno stesso processo, queste arriveranno al ricevente allo stesso ordine, nonostante la rete possa riordinarli


| MPI datatype         | C datatype             |
| -------------------- | ---------------------- |
| `MPI_CHAR`           | `signed char`          |
| `MPI_SHORT`          | `signed short int`     |
| `MPI_LONG`           | `signed long int`      |
| `MPI_LONG_LONG`      | `signed long long int` |
| `MPI_UNSIGNED_CHAR`  | `unsigned char`        |
| `MPI_UNSIGNED_SHORT` | `unsigned short int`   |
| `MPI_UNSIGNED`       | `unsigned int`         |
| `MPI_UNSIGNED_LONG`  | `unsigned long int`    |
| `MPI_FLOAT`          | `float`                |
| `MPI_DOUBLE`         | `double`               |
| `MPI_LONG_DOUBLE`    | `long double`          |
| `MPI_BYTE`           |                        |
| `MPI_PACKED`         |                        |

## Message matching
Message is successfully received if:
- `recv_type = send_type`
- `recv_buf_sz >= send_buf_sz`

A receiver can get a mesasge without knowing:
- the amount of data in the message
- the sender of the message (`MPI_ANY_SOURCE`)
- or the tag of the message (`MPI_ANY_TAG`)

## $\verb|status_p|$ argument

```c
MPI_Recv(recv_buf_p, rect_buf_sz, recv_type, src, recv_tag, recv_comm, &status);
```

```c
int MPI_Get_count(
	MPI_Status*  status_p, // in
	MPI_Datatype type,     // in
	int*         count_p   // out
);
```

>[!error] Issues with send and receive
>- exact behavior is determined by the MPI implementation
>- `MPI_Send` may behave differently with regard to buffer size cutoffs and blocking. quando faccio la send non so se il messaggio sia ancora partito o meno, la mia unica garanzia è che quando eseguo l’istruzione successiva possono essere modificati dato che MPI li ha già copiati su un altro buffer di memoria (sicuramente però gli elementi che sono stati inviati sono quelli prima della modifica)
>- `MPI_Recv` always blocks until a matching message is received
>- even if you know your MPI implementation, stick to what is defined by the standard (don’t assume that the send returns immediately for small buffers), otherwise your code will not be portable

>[!warning] Warnings
>- if a process tries to receive a message and there’s no matching send, then the process will hang
>- if a call to `MPI_Send` blocks and there’s no matching receive, then the sending process can hang
>- if, a call to `MPI_Send` if buffered and there’s no matching reveice then the message will be lost
>- if the rank of the destination process is the same as the rank of the source process, a process will hand, or, perhaps worse, the receive may match another send

