la trasparenza referenziale generalmente non è vera per i linguaggi imperativi

>[!question] Which is the type of `++` operator?
>```haskell
>Prelude> :t (++)
>(++) :: [a] -> [a] -> [a]
>```
>
>`a` is a type variable. The type must be interpreted universally quantified. Indeed:

Some more polimorphic functions:
```haskell
Prelude> :t zip
zip :: [a] -> [b] -> [(a, b)]

Prelude> zip [1,2,3]['a','b']
[(1,'a'),(2,['b'])]

Prelude> :t (.)
(.) :: (b->c) -> (a->b) -> a -> c
```

`(.)` is a function of higher order (functional) beacause it has a parameter other functions. It is function composition

Other functionals:
```haskell
Prelude> :t map
map :: (a->b) -> [a] -> [b]

Prelude> :t zipWith
zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
```

The type of `(+)` is slightly more complicated:
```haskell
Prelude> :t (+)
(+) :: (Num a) => a -> a -> a
```

that has to be read: it is similar to Java interface, and it means that all types on which `(+)` is defined must be numeric types

`Num` is a **class**. Two classes of common use are: `Eq` (that is types with an equality relation) and `Ord` (types with a order relation)

For example, a function `sort` should be possible type:
```haskell
sort :: (Ord a) => [a] -> [a]
```

In Haskell is pre-defined an “undefined constant”
```haskell
Prelude> undefined
*** Exception: Prelude.undefined
```

More intrestingly, the type of `undefined`
```haskell
undefined :: a
```

But which kind of value can be typed as $\forall a.a$?

## Compositionality ed Equations
An important aspect of functional programming is program composition. We now introduce the functional `map` and a first example of equational reasoning

```haskell
map :: (a -> b) -> [a] -> [b]
-- applies a function to all values in a list
> map (*2) [1, 2, 3]
[2, 4, 6]
> map length [“I”, “love”, ”haskell”]
[1, 4, 7]
> :t (.) -- function composition
(.) :: (b -> c) -> (a -> b) -> a -> c
> map ((*2) . length) [“I”, “love”, ”haskell”]
[2, 8, 14] -- function composes!
> map (*2) (map length [“I”, “love”, ”haskell”])
[2, 8, 14]
> (map (*2) . (map length)) [“I”, “love”, ”haskell”]
[2, 8, 14]
```

Informally we prove: `map (f . g) = (map f . map g)`

## Function definitions
A function is defined by giving a name to a definition. Usually functions are defined by recursion.

```haskell
fact n = if n==0 then 1 else n*fact(n-1)
```

>[!hint] Observations

Almost all functions defined in the Haskell `Prelude` could be easily defined in Haskell, by using a very small Haskell fragment.
Let us see the definition of function composition:
```haskell
(.) f g x = f (g x)
```

but also:
```haskell
(f . g) x = f (g x)
```

Mainly, we will use pattern matching (case analysis) and recursion:
```haskell
fatt’ (0, f) = f                -- (0)
fatt’ (n, f) = fatt’ (n-1, f*n) -- (n)
fatt n = fatt’ (n, 1)
```

Another example of pattern matching (here on lists) and recursion (`:` appends an head to a list and it is read as `cons`)
```haskell
map f [] = []
map f (x:xs) = f x : map f xs
```

The pattern `[]` and `x:xs`  distinguish empty from non-empty. Now we defined the list `ones` containing infinite $1$’s
```haskell
ones = 1 : ones -- [1, 1, 1, 1, ...] infinite list
```

Now we defined the function:
```haskell
myHead (x:xs) = x
```

Let’s evaluate `myHead (map (*2) ones)`:
```haskell
> myHead (map (*2) ones)
-- myHead (2 : map (*2) ones)
2
```

ml è eager mentre haskell è NATIVAMENTE lazy