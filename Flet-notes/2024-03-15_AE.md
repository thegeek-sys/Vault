la maggior parte delle istruzioni in assembly sono solamente delle psudoistruzioni, infatti, come si vede nell’interfaccia di MARS, le istruzioni digitate vengono spesso trasformate in più pseudoistruzioni 

la differenza tra word e halfword sta nel fatto che mentre nelle word intere per spostarmi tra un indice al successivo di nu vettore mi devo spostare di 4 byte. in un vettore di half word mi basta spostarmi di due 2 byte alla volta. mentre in un vettore di byte di uno in uno

Quando scrivo in un’etichetta una stringa ascii in memoria verrà scritto un carattere per ogni byte di memoria e al termine di essa verrà aggiunto `\0` (carattere codificato con zero, 0x0)

	LITTLE ENDIANESS E BIG ENDIANESS

## Accedere agli elementi per indice
Esempio
```arm-asm
# $t0 contiene l'indice dell'elemento (e.g. 2)
# $t1 contiene l'indirizzo del vettore (e.g. 0x10010040)
# in $t2 si ottiene l'indirizzo dell'elemento ($t1+offset)

sll $t2,$t0,2 # word -> 4 byte; shift di due bit -> 
			  # moltiplicazione per 4

add $t2,$t2,$t1 # essendo $t2 già indirizzo dell'indice
				# della word mi basta fare lw $s0,$t2 per
				# accedere t0-esimo elemento dell'array
```

Abbiamo quindi due metodi per accedere ad un elemento di un’array:
**Scansione per indice**
- pro
	- comoda se si deve usare l’indice dell’elemento per controlli o altro
	- incremento dell’indice non dipende dalla dimensione degli elementi
	- comoda se il vettore è allorato staticamente (nella sezione .data)
- contro
	- bisogna convertire ogni volta l’indice nel corrispondnete offset in byte

**Scansione per puntatore** (punto direttamente indirizzi in memoria)
- pro
	- si lavora direttamente su indirizzi di memoria
	- ci sono meno calcoli nel ciclo
- contro
	- non si ha a disposizione l’indice dell’elemento
	- l’incremento del puntatore dipende dalla dimensione degli elementi
	- bisogna calcolare l’indirizzo successivo all’ultimo elemento