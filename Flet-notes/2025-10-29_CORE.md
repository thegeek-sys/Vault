## $\verb|MPI_Sendrecv|$
An alternative to scheduling the communications ourselves (and to using `Isend`/`Irecv`/`Wait`)
`MPI_Sendrecv` Carries out a blocking send and a receive in a single call

The dest and the source can be the same or different. Especially helpful because MPI schedules the communication so that the program won’t hang or crash

(esistono anche delle chiamate collettive non bloccanti, Ibcast es restituisce immediatamente il controllo)


## Processes and threads
A process is an instance of a running (or suspended program). Threads are analogous to a “light-weight” process. In a shared memory program a single process may have multiple threads of control

(guarda ppt)
## OpenMP vs. Pthreads
OpenMP provides a higher abstraction interface
- on POSIX systems, it is most likely implemented on top of Pthreads
- on non-POSIX sytem (eg Windows), it will be implemented on top of some other threading abstraction



## How many threads should we run?
In principle, you should try to avoid having more threads than cores but there are situations where it might make sense

## Threads safety in MPI
Are MPI calls thread-safe? (che succede se faccio due MPI send da due thread diversi allo stesso tempo)

```c
int MPI_Init_thread(int *argc, char ***argv, int required, int *provided)
```

argv → same as MPI_Init
required → required “threading level” (IN)
provided → supported “threading level” (OUT)

## Threading levels in MPI
`MPI_THREAD_SINGLE` → ranks is not allowed to use threads, which is basically equivalent to calling MPI_Init
`MPI_THREAD_FUNNELEL` → il processo può creare nuovi thread ma solo il thread principale può usare chiamate MPI
`MPI_THREAD_SERIALIZED` → rank can be (solo uno alla volta può usare MPI) multi-threaded but only one thread at a time may call MPI functions. The rank must ensure that MPI is used in a thread-safe way. One approach is to ensure that MPI usage is mutally excluded by all the threads
`MPI_THREAD_MULTIPLE` → rank can be multi-threaded and any thread may call MPI functions. The MPI library ensures that this access is safe  across threads. Note that this makes all MPI operations less efficient, even if only one thread makes MPI calls, so should be used only when necessary

>[!warning]
>Not all the threading levels are supported by all the MPI implementations (e.g. some implementations might not support `MPI_THREAD_MULTIPLE`)

## Timing code

```c
#include <sys/time.h>

#define GET_TIME(now) { \
   struct timeval t; \
   gettimeofday(&t, NULL); \
   now = t.tv_sec + t.tv_usec/1000000.0; \
}
```

## Performance measurements

>[!bug] Correct performance measurements
>To get correct performance measurements you should rememeber to:
>- disable turbo boos → if possible (temperature-wise) overclock by a little your CPU
>- disable frequency scaling → if possible (temperature-wise) lower the frequency of your CPU