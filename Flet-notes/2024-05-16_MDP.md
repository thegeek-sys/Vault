```java
Colector<Person, StringJoiner, String> personNameCollector =
	Collector.of(
		() -> new StringJoiner(" | "), // supplier
		// j è lo StringJoiner
		(j, p) -> j.add(p.name.toUpperCase()), // accumulator
		// fa il merge di tutti gli StringJoiner pronti dato
		// che implicitamente si hanno molti StringJoiner
		// eseguiti in parallelo
		(j1, j2) -> j1.merge(j2), // combiner
		StringJoiner::toString // finisher
	);
	
	String names = people.stream()
						 .collect(personNmaeCollector);
	System.out.println(names); // MAX | PETER | PAMELA
```

## partitioningBy
simile a `goupingBy`
`partitioningBy(predicato)`: raggruppa in una `Map<Boolean, List<T>>`
```java
// crea una mappa da booleano a lista di interi che 
// soddisfano quel criterio del predicato in input
Map<Boolean, List<Integer>> m =
l.stream()
 .collect(Collectors.partitioningBy(x -> x % 2 == 0));
```

## distinct (intermedia)
Restituisce un nuovo stream senza ripetizione di elementi (gli elementi sono tutti distinti tra loro) basandosi sul metodo equals

```java
List<Integer> l = List.of(3, 4, 5, 3, 4, 1);
List<Integer> distinti = l.stream()
						  .map(x -> x*x)
						  .distinct()
						  .collect(Collectors.toList());
```

## reduce (terminale)
`reduce` è un’operazione terminale che effettua una riduzione sugli elementi dello stream utilizzando la funzione data in input

```java
// iterativamente
int somma = 0;
for (int k : lista)
	somma += k;


// tramite stream
lista.stream().reduce(0, (a, b) -> a+b);
// oppure
lista.stream().reduce(0, Integer::sum);
```

![[Screenshot 2024-05-16 alle 12.48.12.png]]

Esiste anche una versione di reduce con un solo parametro (senza elemento identità), che restituisce un `Optional<T>`:

```java
lista.stream().reduce(Integer::sum);
```

Perché `Optional<T>`? Perché se lo stream è vuoto, non
avendo l'elemento identità non si sa quale valore
restituire

Ad esempio, riduciamo uno stream di String a una stringa costruendola elemento per elemento
```java

```