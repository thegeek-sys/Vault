```python
with open('check.asm') as fr, open()
```

Si possono interpretare le immagini come delle vere e proprie matrici di pixel, in cui ogni pixel è formato da una lista o una tupla composta di da tre valori rappresentanti R G e B

```python
matrix_3x2 = [[0,1],[1,2],[2,3]]
r = len(matrix_3x2)
c = len(matrix_3x2[0])

def print_matrix(m):
	for r in m:
		print(r)

def create_matrix(r,c,value=0):
	# define matrix
	matrix = []
	# for each row
	for each_r in range(r):
		# define row
		row = []
		# for each row
		for each_c in range(c):
			row.append(value)
		matrix.append(row)
	return matrix

matrix_20x20 = create_matrix(20,20)
print_matrix(matrix_20x20)
```

Potremmo anche pensare di definire una matrice utilizzando la concatenazione di tipi, ma questo non funzionerà poiché se dopo provo a scrivere in un singolo pixel mi scriverà nell’intera colonna corrispondente

```python
def create_matrix_short(r,c,value=0):
	return [[value]*c*r]
```


## Shallow vs Deep Copy
## Shallow copy
Crea una nuova variabile `dst` ma che non occupa spazio in memoria infatti sarà solo un rifereimento ad un altra variabile
```python
import copy
l_sc1 = list(l)
l_sc2 = l.copy()
l_sc3 = l[:]
l_sc4 = copy.copy(l)
```
## Deep copy
Nella deep copy viene effettivamente duplicata la variabile e creata una nuova allocazione di memoria
```python
import copy
l_dc1 = copy.deepcopy()
```

Negli oggetti immutabili però la deep copy non esiste